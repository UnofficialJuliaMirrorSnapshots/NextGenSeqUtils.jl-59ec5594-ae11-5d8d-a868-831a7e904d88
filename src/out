aliases.jl:# alias function names, because old scripts rely on the original
align.jl:function nw_align(s1::String, s2::String; edge_reduction = 0.99)
align.jl:function nw_align(s1::String, s2::String, banded::Float64)
align.jl:function add_to_band!(band, val, i::Int, j::Int, bandwidth::Int, dim_diff::Int)
align.jl:function get_band_val(band, i::Int, j::Int, bandwidth::Int, dim_diff::Int)
align.jl:function in_band(i, j, bandwidth, dim_diff)
align.jl:function banded_nw_align(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1)
align.jl:function triplet_nw_align(s1::String, s2::String; edge_reduction = 0.99, boundary_mult = 2)                
align.jl:function local_align(ref::String, query::String; mismatch_score = -1, 
align.jl:function unique_key(dicto::Dict{String, Int}, keyo::String, indo::Int)
align.jl:function clean_unique_key(dicto::Dict{String, Int})
align.jl:function sorted_matches(s1, s2, wordlength, skip, aligncodons)
align.jl:function sorted_aa_matches(str1, str2, wordlength)
align.jl:function matches_are_inconsistent(matches)
align.jl:function clean_matches(matches, wordlength, skip)
align.jl:function merge_overlapping(matches, wordlength, skip)
align.jl:function get_matches(s1, s2, clean, range_inds, wordlength)
align.jl:function get_mismatches(s1, s2, matches, range_inds, wordlength)
align.jl:function longest_incr_subseq(arr::Array{Int, 2})
align.jl:function kmer_seeded_align(s1::String, s2::String;
align.jl:function triplet_kmer_seeded_align(s1::String, s2::String;
align.jl:function local_kmer_seeded_align(s1::String, s2::String;
align.jl:function kmer_seeded_edit_dist(s1::String , s2::String;
align.jl:function resolve_alignments(ref::String, query::String; mode = 1)
align.jl:function align_reading_frames(clusters; k = 6, thresh = 0.03, verbose = false)
align.jl:function local_edit_dist(s1::String, s2::String)
demux.jl:function toIUPACnum(strin::String)
demux.jl:function IUPAC_equals(a1,a2)
demux.jl:function IUPAC_nuc_edit_dist(s1::String, s2::String; edge_reduction = 0.9999)
demux.jl:function IUPAC_nuc_nw_align(s1::String, s2::String; edge_reduction = 0.9999)
demux.jl:function banded_edit_dist(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1)
demux.jl:function maxcoord(mat)
demux.jl:function matchPrimer(seq,forwardPrimers,revPrimers,forwardNames,revNames)
demux.jl:function deMux(seqs,forwardPrimers,reversePrimers, forwardNames,reverseNames)
demux.jl:function demux_fastx(fwdPrimers, revPrimers; minLen = 2300, errorRate = 0.01,
exports.jl:# Used to keep function names in namespace of any script using BeNGS
exports.jl:# without needing to call functions with BeNGS.<function>
exports.jl:# keep this up to date with function names along with aliases.jl
hmm.jl:function viterbi_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})
hmm.jl:function trans_mat(; uniform_cycle_prob = 0.9999999999, homopoly_cycle_prob = 0.98)
hmm.jl:function obs_mat(; homopoly_prob = 0.99)
hmm.jl:function initial_dist(; uniform_state = 0.99)
hmm.jl:function get_obs_given_state(observation_matrix::Array{Float64,2}, observation_seq::String)
hmm.jl:function homopolymer_filter(seqs::Array{String,1}, phreds, names;
hmm.jl:function homopolymer_filter(sourcepath::String, destpath::String;
hmm.jl:function forward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})
hmm.jl:function backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})
hmm.jl:function forward_backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})
hmm.jl:function gen_seq_with_model(n::Int, trans_mat, obs_mat, initial_dists)
hmm.jl:function viterbiprint(s::String)
io.jl:function read_fasta_records(filename)
io.jl:function read_fasta(filename; seqtype=String)
io.jl:function read_fasta_with_names(filename; seqtype=String)
io.jl:function read_fasta_with_names_in_other_order(filename::String; seqtype=String)
io.jl:function write_fasta(filename::String, seqs; names = String[])
io.jl:function read_fastq_records(filename)
io.jl:function read_fastq(filename; seqtype=String)
io.jl:function write_fastq(filename, seqs, phreds::Vector{Vector{Phred}};
kmers.jl:function kmer_count(str::String, k::Int)
kmers.jl:function sparse_aa_kmer_count(str::String, k::Int)
kmers.jl:"""Compute distance function that is correct for small differences."""
kmers.jl:function corrected_kmer_dist(kmers1::Array, kmers2::Array; k = nothing)
kmers.jl:function corrected_kmer_dist(k::Int)
kmers.jl:    function kdist(kmers1, kmers2)
orient.jl:function orient_strands(seqs::Array{String}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, ref::String; k::Int=6)
orient.jl:function orient_strands(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, 
orient.jl:function orient_to_refs_file(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, refspath::String)
orient.jl:function orient_to_refs(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, refs::Array{String,1}; k::Int = 6)
orient.jl:    function orientate(sq::String, ph::Vector{Phred}, name::String)
orient.jl:#function orient_strands(seqs::Array{String, 1}; radius = 0.3, k = 4)
phreds.jl:@generated function phred_to_log_p(x)
phreds.jl:function phred_to_p(q::Phred)
phreds.jl:function phred_to_p(x::Vector{Phred})
phreds.jl:function p_to_phred(p::Prob)
phreds.jl:function p_to_phred(x::Vector{LogProb})
phreds.jl:function error_probs_to_phreds(eps::Vector{Float64})
phreds.jl:function quality_filter(infile,outfile=join(split(infile, ".")[1:end-1], ".") * ".filt.fasta" ; errorRate=0.01,minLength=100,labelPrefix="seq",errorOut = true)
phreds.jl:function quality_filter(seqs::Array{String, 1}, scores::Array, names::Array{String, 1}; errorRate=0.01,minLength=0)
phreds.jl:function quality_filter_inds(seqs::Array{String, 1}, scores::Array; errorRate=0.01,minLength=100)
phreds.jl:function length_vs_qual(fasta_path; plot_title = "Length Vs Errors")
phreds.jl:function qual_hist(fasta_path; plot_title = "Quality Hist")
simulation.jl:"""Sequence simulation functions"""
simulation.jl:function flip(p, t, f)
simulation.jl:function simple_gen_seq(n::Int)
simulation.jl:function simple_evolve(refseq, err_rate)
simulation.jl:function fixed_diff_evolve(template::String, n_diffs::Int64)
simulation.jl:This function will need to be tweaked to approximate how the error
simulation.jl:function pb_error_inflation(old_length::Int64)
simulation.jl:function length_error_func(old_length::Int64; rate = 0.002)
simulation.jl:function pb_seq_sim(template::String, rate::Float64; with_qvs = false)
simulation.jl:    # or the pb_error_inflation functions change.
simulation.jl:function env_error_rates(n)
simulation.jl:function env_pb_seq_sim(template::String, n::Int64; with_qvs = false)
utils.jl:function dist_matrix(distr1, distr2; dist_met = kmer_seeded_edit_dist)
utils.jl:function symmetric_dist_matrix(distr; dist_met = kmer_seeded_edit_dist)
utils.jl:function print_fasta(seqs, names)
utils.jl:function degap(s::String)
utils.jl:function degap(s::DNASequence)
utils.jl:function dash_count(inStr::String)
utils.jl:function single_gap(str::String, ind::Int)
utils.jl:function single_mod_three_gap(str::String, ind::Int)
utils.jl:function triple_gap(str::String, ind::Int)
utils.jl:function seq_details(fasta_path)
utils.jl:function print_rgb(r, g, b, t)
utils.jl:function reverse_complement(dna_string::String)
utils.jl:function print_diffs(s1, s2; width=5, prefix="")
utils.jl:function trim_ends_indices(seq, ref; edge_reduction=0.1)
utils.jl:function translate_to_aa(s::String)
utils.jl:function generate_aa_seqs(str::String)
utils.jl:function length_filter_inds(seqs::Array{String, 1}, minlength::Int, maxlength::Int)
utils.jl:function length_filter(seqs::Array{String, 1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void},
utils.jl:function length_filter(seqs::Array{String, 1}, minlength::Int64, maxlength::Int64)
utils.jl:function filter_by_length(args...)
utils.jl:function concat_fastas(filepaths::Array{String, 1}, outfile::String)
utils.jl:function maxfreq(vec)
utils.jl:function freq(vec, elem)
utils.jl:function sorted_freqs(vec)
utils.jl:function freq_dict_print(dictin; thresh=0)
utils.jl:function logsum(lga, lgb)
wrappers.jl:function usearch_filter(inFastqPath, outFastXPath;
wrappers.jl:function usearch_ref(inFastXPath, outFastaPath, referenceString;
wrappers.jl:function usearch_ref_database(inFastXPath, outFastaPath, referencePath;
wrappers.jl:function mafft(inpath, outpath; path="", flags::Vector{String}=String[], kwargs...)
wrappers.jl:function mafft_consensus{T<:BioSequence}(seqs::Vector{T}; kwargs...)
